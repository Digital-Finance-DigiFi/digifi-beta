from typing import (Union, Any, Type)
import abc
import numpy as np
from digifi.utilities.general_utils import (compare_array_len, type_check)
from digifi.stochastic_processes.sde_components_utils import (SDEComponentFunctionType, SDEComponentFunctionParams,
                                                                  CustomSDEComponentFunction, NoiseType, CustomNoise, JumpType,
                                                                  CompoundPoissonNormalParams, CompoundPoissonBilateralParams, CustomJump)
from digifi.stochastic_processes.sde_components import (Drift, Diffusion, Jump)
from digifi.stochastic_processes.stochastic_drift_components import (StochasticDriftType, TrendStationaryTrendType, TrendStationaryParams,
                                                                         CustomTrendStationaryFunction, StationaryErrorType, CustomError,
                                                                         DifferenceStationary, TrendStationary, StationaryError)



class StochasticProcessInterface(metaclass=abc.ABCMeta):
    @classmethod
    def __subclasshook__(cls, subclass) -> bool:
        return (hasattr(subclass, "get_paths") and
                callable(subclass.get_paths) and
                hasattr(subclass, "get_expectation") and
                callable(subclass.get_expectation))
    
    @abc.abstractmethod
    def get_paths(self) -> np.ndarray[Any, np.ndarray]:
        """
        ## Description
        Paths, S, of the stochastic process.
        """
        raise NotImplementedError
    
    @abc.abstractmethod
    def get_expectation(self) -> np.ndarray:
        """
        ## Description
        Expected path, E[S], of the stochastic process.
        """
        raise NotImplementedError



class SDE:
    """
    ## Description
    Defines an SDE in the generalized form.\n
    SDE = Drift + Diffusion + Jump
    ### Input:
        - T: Final time step
        - s_0: Starting point for the process
        - n_steps: Number of steps a process makes after the starting point
        - n_paths: Number of paths (i.e., iterations) to return
        - drift_component_type: Type of function \\mu(S_{t}, t) to be used when constructing the drift
        - drift_component_params: Parameters of the chosen drift function
        - custom_drift: Definition of the custom drift function
        - diffusion_component_type: Type of function \\sigma(S_{t}, t) to be used when constructing the diffusion
        - diffusion_component_params: Parameters of the chosen diffusion function
        - custom_diffusion: Definition of the custom diffusion function
        - custom_noise: Custom noise object used to generate noise inside diffusion
        - jump_type: Type of function dJ to be used when constructing the jump
        - custom_jump: Definition of the custom jump function
    ### Output:
        - paths: Random walks generated by the defined SDE
    ### LaTeX Formula:
        - dS_{t} = \\mu(S_{t}, t)dt + \\sigma(S_{t}, t)dW_{t} + dJ
    ### Links:
        - Wikipedia: https://en.wikipedia.org/wiki/Stochastic_differential_equation
        - Original SOurce: N/A
    """
    def __init__(self, T: float, s_0: float, n_steps: int, n_paths: int=100,
                 # Drift
                 drift_component_type: SDEComponentFunctionType=SDEComponentFunctionType.LINEAR,
                 drift_component_params: SDEComponentFunctionParams=SDEComponentFunctionParams(),
                 custom_drift: Union[Type[CustomSDEComponentFunction], None]=None,
                 # Diffusion
                 diffusion_component_type: SDEComponentFunctionType=SDEComponentFunctionType.LINEAR,
                 diffusion_component_params: SDEComponentFunctionParams=SDEComponentFunctionParams(),
                 custom_diffusion: Union[Type[CustomSDEComponentFunction], None]=None,
                 noise_type: NoiseType=NoiseType.WEINER_PROCESS,
                 custom_noise: Union[Type[CustomNoise], None]=None,
                 #Jumps
                 jump_type: JumpType=JumpType.NO_JUMPS,
                 jump_params: Union[CompoundPoissonNormalParams, CompoundPoissonBilateralParams, None]=None,
                 custom_jump: Union[Type[CustomJump], None]=None) -> None:
        # General parameters
        self.T = float(T)
        self.s_0 = float(s_0)
        self.n_steps = int(n_steps)
        self.dt = self.T/self.n_steps
        self.n_paths = int(n_paths)
        self.t = np.arange(self.dt, T+self.dt, self.dt)
        # Drift term and parameters
        self.drift = Drift(n_paths=self.n_paths, dt=self.dt, component_type=drift_component_type,
                           component_params=drift_component_params, custom_drift=custom_drift)
        # Diffusion term and parameters
        self.diffusion = Diffusion(n_paths=self.n_paths, dt=self.dt, component_type=diffusion_component_type,
                                   component_params=diffusion_component_params, custom_diffusion=custom_diffusion, noise_type=noise_type,
                                   custom_noise=custom_noise)
        # Jump term and parameters
        self.jump = Jump(n_paths=self.n_paths, dt=self.dt, jump_type=jump_type, jump_params=jump_params, custom_jump=custom_jump)

    def get_paths(self) -> np.ndarray[Any, np.ndarray]:
        """
        ## Description
        Generate paths for the constructed SDE.
        ### Output:
            - Array (np.ndarray[Any, np.ndarray]) of random paths
        """
        time_steps = [self.s_0 * np.ones(self.n_paths)]
        for i in self.t:
            time_slice = (self.drift.get_drift(previous_values=time_steps[-1], t=i)
                          + self.diffusion.get_diffusion(previous_values=time_steps[-1], t=i)
                          + self.jump.get_jumps())
            time_steps.append(time_steps[-1] + time_slice)
        return np.array(time_steps).T
    


class StochasticDrift:
    """
    ## Description
    Defines a stochastic process in the generalized where the stochastic drift can be difference-stationary (i.e., autoregressive) or trend-stationary (i.e., only time dependent).\n
    Stochastic Drift Process = Trend + Stationary Error
    ### Input:
        - stochastic_drift_type: Type of stochastic drift
        - T: Final time step
        - n_steps: Number of steps a process makes after the starting point
        - n_paths: Number of paths (i.e., iterations) to return
        - autoregression_parameters: Parameters for the difference stationary process
        - difference_stationary_start: Set of points that define starting points for the difference stationary process
        - trend_stationary_type: Type of trend function to be used in the construction of a trend-stationary process
        - trend_stationary_params: Parameters accompanying the choice of the trend-stationary type
        - custom_tren_stationary: Custom function to be used for the custruction a trend-stationary process
        - error_type: Type of error function to be used in the construction of an error term
        - custom_error: Custom error function to be used for the construction of an error term
    ### Ouput:
        - paths: Random walks generated by the defined stochastic drift process
    ### LaTeX Formula:
        - S_{t} = \\mu(S_{0}, ..., S_{t-1}, t) + e_{t}
    ### Links:
        - Wikipedia: https://en.wikipedia.org/wiki/Stochastic_drift
        - Original Source: N/A
    """
    def __init__(self, stochastic_drift_type: StochasticDriftType, T: float, n_steps: int, n_paths: int=100,
                 # Difference-stationary
                 autoregression_parameters: np.ndarray=np.array([]),
                 difference_stationary_start: np.ndarray=np.array([]),
                 # Trend-stationary
                 trend_stationary_type: TrendStationaryTrendType=TrendStationaryTrendType.LINEAR,
                 trend_stationary_params: TrendStationaryParams=TrendStationaryParams(),
                 custom_trend_stationary: Union[CustomTrendStationaryFunction, None]=None,
                 #Stationary error
                 error_type: StationaryErrorType=StationaryErrorType.WEINER, sigma: float=1.0,
                 custom_error: Union[Type[CustomError], None]=None) -> None:
        # Arguments validation
        type_check(value=stochastic_drift_type, type_=StochasticDriftType, value_name="stochastic_drift_type")
        self.stochastic_drift_type = stochastic_drift_type
        self.T = float(T)
        self.n_steps = int(n_steps)
        self.dt = self.T/self.n_steps
        self.n_paths = int(n_paths)
        self.t = np.arange(0.0, T+self.dt, self.dt)
        self.time_steps = list()
        match self.stochastic_drift_type:
            case StochasticDriftType.DIFFERENCE_STATIONARY:
                compare_array_len(array_1=difference_stationary_start, array_2=autoregression_parameters,
                                  array_1_name="difference_stationary_start", array_2_name="autoregression_parameters")
                time_steps = list()
                for _ in range(n_paths):
                    time_steps.append(difference_stationary_start)
                self.time_steps = list(np.array(time_steps).T)
            case StochasticDriftType.TREND_STATIONARY:
                pass
        # Difference-stationary component
        self.difference_stationary = DifferenceStationary(n_paths=self.n_paths, autoregression_parameters=autoregression_parameters)
        # Trend-stationary component
        self.trend_stationary = TrendStationary(n_paths=self.n_paths, trend_type=trend_stationary_type, trend_params=trend_stationary_params,
                                                custom_trend=custom_trend_stationary)
        # Stationary error component
        self.stationary_error = StationaryError(n_paths=self.n_paths, dt=self.dt, error_type=error_type, sigma=sigma,
                                                custom_error=custom_error)
    
    def get_paths(self) -> np.ndarray[Any, np.ndarray]:
        """
        ## Description
        Generate paths for the constructed process.
        ### Output:
            - Array (np.ndarray[Any, np.ndarray]) of random paths
        """
        for i in range(len(self.t)):
            match self.stochastic_drift_type:
                case StochasticDriftType.DIFFERENCE_STATIONARY:
                    time_slice = (self.difference_stationary.get_autoregression(previous_values=self.time_steps, t=self.t[i])
                                  + self.stationary_error.get_error())
                case StochasticDriftType.TREND_STATIONARY:
                    if self.trend_stationary.trend_type==TrendStationaryTrendType.EXPONENTIAL:
                        time_slice = (self.trend_stationary.get_stationary_trend(t=self.t[i]) * np.exp(self.stationary_error.get_error()))
                    else:
                        time_slice = (self.trend_stationary.get_stationary_trend(t=self.t[i]) + self.stationary_error.get_error())
            self.time_steps.append(time_slice)
        return np.array(self.time_steps).T